<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SmallBlue</title>
  <icon>https://www.gravatar.com/avatar/41241fb40a30ee6bd5f545ff1aba6f3f</icon>
  <subtitle>less is more</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-13T17:17:22.448Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>xiaolan</name>
    <email>topyfeng@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python全局解释所GIL</title>
    <link href="http://example.com/2021/04/13/python%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E6%89%80GIL/"/>
    <id>http://example.com/2021/04/13/python%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E6%89%80GIL/</id>
    <published>2021-04-13T13:03:08.000Z</published>
    <updated>2021-04-13T17:17:22.448Z</updated>
    
    <content type="html"><![CDATA[<h4 id="python的GIL作用与瓶颈"><a href="#python的GIL作用与瓶颈" class="headerlink" title="python的GIL作用与瓶颈"></a>python的GIL作用与瓶颈</h4><p>由于引用计数的内存管理方式带来的线程安全问题，GIL进行了很好地解决，全场一个锁，避免引入大量锁，增加申请释放成本开销，增加死锁风险，GIL更加高效，不过GIL会限制多个线程并发执行，对于CPU密集型任务不友好<br>若抛弃GIL，则会是原本C的扩展失效，以及单线程性能降低，而使用多进程代替多线程任务则可避免GIL引起的问题，但是，进程创建开销更大，使用jpython也可绕过GIL，当然，执行io密集型任务时，还是适合采用多线程方式</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;python的GIL作用与瓶颈&quot;&gt;&lt;a href=&quot;#python的GIL作用与瓶颈&quot; class=&quot;headerlink&quot; title=&quot;python的GIL作用与瓶颈&quot;&gt;&lt;/a&gt;python的GIL作用与瓶颈&lt;/h4&gt;&lt;p&gt;由于引用计数的内存管理方式带来的线程</summary>
      
    
    
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python装饰器执行调用流程</title>
    <link href="http://example.com/2021/04/10/python%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%89%A7%E8%A1%8C%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://example.com/2021/04/10/python%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%89%A7%E8%A1%8C%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/</id>
    <published>2021-04-09T16:10:03.000Z</published>
    <updated>2021-04-17T15:21:54.448Z</updated>
    
    <content type="html"><![CDATA[<h4 id><a href="#" class="headerlink" title></a></h4><p>装饰器函数在被装饰函数定义之后就立即加载执行了<br>def outer(f):<br>    def iner():<br>        ret = f()<br>        return ret<br>    return iner</p><p>@ouoter<br>def f():<br>    print(‘hi’)<br>其中<br>f()<br>等价于<br>f() == outer(iner(f))()    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def pets(puppy):  </span><br><span class="line">    print(&#39;biubiubiu~~~~~~&#39;)    </span><br><span class="line">    def bark():   </span><br><span class="line">        print(&#39;汪汪汪~~~~~~&#39;)</span><br><span class="line">        return puppy()  # 加上括号 puppy() &#x3D;&#x3D; dog()</span><br><span class="line">    return bark  # 加上括号，直接返回调用bark值</span><br><span class="line">@pets  # 装饰器</span><br><span class="line">def dog():  # 被装饰函数</span><br><span class="line">    print(&#39;我饿了！&#39;)</span><br><span class="line"></span><br><span class="line"># dog()</span><br><span class="line"></span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"># 没有调用被装饰函数，先执行装饰器函数</span><br><span class="line">biubiubiu~~~~~~</span><br><span class="line"></span><br><span class="line"># 调用被装饰器函数，则打印如下</span><br><span class="line">biubiubiu~~~~~~</span><br><span class="line">汪汪汪~~~~~~</span><br><span class="line">我饿了！</span><br><span class="line"></span><br><span class="line"># 若return bark加上括号，则不用调用被装饰器函数，同样实现效果</span><br><span class="line">biubiubiu~~~~~~</span><br><span class="line">汪汪汪~~~~~~</span><br><span class="line">我饿了！</span><br></pre></td></tr></table></figure><p>在函数定义阶段：执行顺序是从最靠近函数的装饰器开始，自内而外的执行<br>在函数执行阶段：执行顺序由外而内，一层层执行</p><p>关于多个装饰顺序，看下面列子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">def decrator_a(func):</span><br><span class="line">    print(&quot;enter decrator_a&quot;)</span><br><span class="line"></span><br><span class="line">    def inner_a(*args, **kwargs):</span><br><span class="line">        print(&quot;enter inner_a&quot;)</span><br><span class="line">        ret &#x3D; func(*args, **kwargs)</span><br><span class="line">        print(&quot;leaving  inner_a&quot;)</span><br><span class="line">        return ret</span><br><span class="line"></span><br><span class="line">    print(&quot;leaving decrator_a&quot;)</span><br><span class="line">    return inner_a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def decrator_b(func):</span><br><span class="line">    print(&quot;enter decrator_b&quot;)</span><br><span class="line"></span><br><span class="line">    def inner_b(*args, **kwargs):</span><br><span class="line">        print(&quot;enter inner_b&quot;)</span><br><span class="line">        ret &#x3D; func(*args, **kwargs)</span><br><span class="line">        print(&quot;leaving  inner_b&quot;)</span><br><span class="line">        return ret</span><br><span class="line"></span><br><span class="line">    print(&quot;leaving decrator_b&quot;)</span><br><span class="line">    return inner_b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@decrator_a</span><br><span class="line">@decrator_b</span><br><span class="line">def f(*args, **kwargs):</span><br><span class="line">    print(&quot;&#x3D;&#x3D;f&#x3D;&#x3D;&quot;)</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">enter decrator_b</span><br><span class="line">leaving decrator_b</span><br><span class="line">enter decrator_a</span><br><span class="line">leaving decrator_a</span><br><span class="line">enter inner_a</span><br><span class="line">enter inner_b</span><br><span class="line">&#x3D;&#x3D;f&#x3D;&#x3D;</span><br><span class="line">leaving  inner_b</span><br><span class="line">leaving  inner_a</span><br><span class="line"></span><br><span class="line"># f &#x3D; decrator_a(decrator_b(f))</span><br><span class="line"># f() &#x3D; decrator_a(decrator_b(f))()</span><br><span class="line"># 执行顺序：decrator_b-&gt;decrator_a-&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;装饰器函数在被装饰函数定义之后就立即加载执行了&lt;br&gt;def outer(f):&lt;br&gt;    def iner():&lt;br&gt;        ret = f()&lt;br&gt;</summary>
      
    
    
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python迭代器执行调用分析</title>
    <link href="http://example.com/2021/04/10/python%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%89%A7%E8%A1%8C%E8%B0%83%E7%94%A8%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2021/04/10/python%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%89%A7%E8%A1%8C%E8%B0%83%E7%94%A8%E5%88%86%E6%9E%90/</id>
    <published>2021-04-09T16:09:42.000Z</published>
    <updated>2021-04-09T16:09:42.917Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>MYSQL索引</title>
    <link href="http://example.com/2021/03/06/MYSQL%E7%B4%A2%E5%BC%95/"/>
    <id>http://example.com/2021/03/06/MYSQL%E7%B4%A2%E5%BC%95/</id>
    <published>2021-03-06T06:15:58.000Z</published>
    <updated>2021-03-06T15:03:09.733Z</updated>
    
    <content type="html"><![CDATA[<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>索引是，索引有助于更快地获取信息，加快数据的检索速度，保证表中数据的唯一性，加快表之间的连接，但是，需要占用数据表以外的物理存储空间，创建索引和维护索引要花费一定的时间，当对表进行更新操作时，索引需要被重建，这样降低了数据的维护速度。</p><h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><ul><li><p>普通索引<br>基本普通索引，无限制<br><code>create index indexname on table (a) </code></p></li><li><p>唯一性索引<br>基本普通索引，索引列唯一，允许空值<br><code>create ubique index indexname on table(a)</code></p></li><li><p>主键索引<br>特殊的唯一索引，不允许空值</p></li><li><p>聚集索引<br>聚集索引是指索引序列与表中行的排列顺序一致，表中行的物理顺序与键值的逻辑（索引）顺序相同<br>由于主键的作用是将表数据格式转换成平衡树的格式存放，所以一个表只能有一个主键，一个表只能有一个聚集索引<br>建议使用聚集索引的情况：<br>a. 此列包含有限数目的不同值；<br>b. 查询的结果返回一个区间的值；<br>c. 查询的结果返回某值相同的大量结果集</p></li><li><p>非聚集索引（辅助索引）<br>非聚集索引是指索引序列与表中行的排列顺序不一致，聚集索引和非聚集索引都采用了B+树的结构，但非聚集索引的叶子层并不与实际的数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针的方式。<br>建议使用非聚集索引的情况：<br>a. 此列包含了大量数目不同的值；<br>b. 查询的结束返回的是少量的结果集；<br>c. order by 子句中使用了该列。</p></li><li><p>联合索引<br>多个字段上建立的索引，能够加速复合查询条件的检索（最左原则）</p></li><li><p>覆盖索引<br>查询字段为索引，查询性能最佳</p></li></ul><h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h4><p>1.查询条件中有<code>or</code><br>2.联合索引中未用前导列<br>3.<code>like</code>查询以<code>%</code>开头<br>4.全表扫描比索引要快</p><h4 id="建立索引的原则"><a href="#建立索引的原则" class="headerlink" title="建立索引的原则"></a>建立索引的原则</h4><p>在最频繁使用、用以缩小查询范围、需要排序的字段 YES<br>对于查询中很少涉及的字段或者重复值比较多、特殊数据类型的字段 NO</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h4&gt;&lt;p&gt;索引是，索引有助于更快地获取信息，加快数据的检索速度，保证表中数据的唯一性，加快表之间的连接，但是，需要占用数据表以外的物理存储空间，创建索</summary>
      
    
    
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>linux连接文件</title>
    <link href="http://example.com/2021/02/21/linux%E8%BF%9E%E6%8E%A5/"/>
    <id>http://example.com/2021/02/21/linux%E8%BF%9E%E6%8E%A5/</id>
    <published>2021-02-21T14:11:59.000Z</published>
    <updated>2021-02-21T14:12:54.850Z</updated>
    
    <content type="html"><![CDATA[<p><strong>链接文件的概念类似于windows里的快捷方式。多个链接文件同时指向一个“源文件”。链接文件分为硬链接或符号链接两种</strong>。</p><p>在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号inode 。软连接，其实就是新建立一个文件，这个文件就是专门用来指向别的文件的（那就和windows 下的快捷方式的那个文件有很接近的意味）。软连接产生的是一个新的文件，但这个文件的作用就是专门指向某个文件的，删了这个软连接文件，那就等于不需要这个连接，和原来的存在的实体原文件没有任何关系，但删除原来的文件，则相应的软连接不可用（cat那个软链接文件，则提示“没有该文件或目录“）</p><p>硬连接是不会建立inode的，他只是在文件原来的inode link count域再增加1而已，也因此硬链接是不可以跨越文件系统的。相反都是软连接会重新建立一个inode，当然inode的结构跟其他的不一样，他只是一个指明源文件的字符串信息。一旦删除源文件，那么软连接将变得毫无意义。而硬链接删除源文件的时候，系统调用会检查inode link count的数值，如果他大于等于1，那么inode不会被回收，因此文件的内容不会被删除，相当于删除了一个索引。</p><p>硬链接实际上是为文件建一个别名，链接文件和原文件实际上是同一个文件。可以通过ls -i来查看一下，这两个文件的inode号是同一个，说明它们是同一个文件；而软链接建立的是一个指向，即链接文件内的内容是指向原文件的指针，它们是两个文件。</p><p>软链接可以跨文件系统，硬链接不可以；软链接可以对一个不存在的文件名(filename)进行链接（当然此时如果你vi这个软链接文件，linux会自动新建一个文件名为filename的文件）,硬链接不可以（其文件必须存在，inode必须存在）；软链接可以对目录进行连接，硬链接不可以。两种链接都可以通过命令 ln 来创建。ln 默认创建的是硬链接。使用 -s 开关可以创建软链接</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;链接文件的概念类似于windows里的快捷方式。多个链接文件同时指向一个“源文件”。链接文件分为硬链接或符号链接两种&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号inode</summary>
      
    
    
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Could not open lock file/var/lib/dpkg/lock的解决办法</title>
    <link href="http://example.com/2021/02/21/Could-not-open-lock-file-var-lib-dpkg-lock%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://example.com/2021/02/21/Could-not-open-lock-file-var-lib-dpkg-lock%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</id>
    <published>2021-02-21T13:22:22.000Z</published>
    <updated>2021-03-06T14:19:03.173Z</updated>
    
    <content type="html"><![CDATA[<p>在ubuntu系统中使用apt-get install xxx的时候，有时候会出现无法获得锁的权限问题。这是因为有另外一个进程在占用锁。类似以下的错误提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E: Could not open lock file &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock-frontend - open (13: Permission denied)</span><br><span class="line">E: Unable to acquire the dpkg frontend lock (&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock-frontend), are you root?</span><br></pre></td></tr></table></figure><p><strong>可能原因</strong>：<br>之前也用apt-get命令安装某个资源但是没有安装完就关闭terminal了，再次打开时导致了另外一个进程正在占用 apt-get install 进程。由于在运行时，会占用软件源更新时的系统锁，此时就会发生报错。</p><p><strong>解决</strong><br>依次运行下列4条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock</span><br><span class="line">sudo rm -rf &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F;lock</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo dpkg --configure -a</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在ubuntu系统中使用apt-get install xxx的时候，有时候会出现无法获得锁的权限问题。这是因为有另外一个进程在占用锁。类似以下的错误提示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;</summary>
      
    
    
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>面试-tcp协议</title>
    <link href="http://example.com/2021/02/20/%E9%9D%A2%E8%AF%95-tcp%E5%8D%8F%E8%AE%AE/"/>
    <id>http://example.com/2021/02/20/%E9%9D%A2%E8%AF%95-tcp%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-02-20T06:19:53.000Z</published>
    <updated>2021-03-06T14:19:03.169Z</updated>
    
    <content type="html"><![CDATA[<hr><h4 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h4><p>tcp是一个面向连接的、可靠的、基于字节流的传输层协议<br>udp是一个面向无连接的传输层协议</p><p><code>tcp三大特性</code>：<br><strong>面向连接</strong>。即客户端与服务器之间的连接，在双方通信之前，tcp需要三次握手建立连接，而udp则不用建立相应的连接。<br><strong>可靠性</strong>。tcp的连接具有可靠性，一个是有状态，tcp会记录数据的接收和丢失，进行差错检验并且保证数据包按序到达。另一个是可控，当丢包发生或者网络环境不佳，会根据情况调整行为，控制发送速度或者是重发。<br><strong>面向字节流</strong>。udp的数据传输基于数据报，由其继承IP层的特性，并且为了维护状态将IP包变成字节流。</p><hr><h4 id="TCP-三次握手的过程"><a href="#TCP-三次握手的过程" class="headerlink" title="TCP 三次握手的过程"></a>TCP 三次握手的过程</h4><p>TCP 在传输之前会进行三次沟通，一般称为“三次握手”，传完数据断开的时候要进行四次沟通，一般 称为“四次挥手”。</p><p><img src="/2021/02/20/%E9%9D%A2%E8%AF%95-tcp%E5%8D%8F%E8%AE%AE/a.jpg" alt="&#39;三次握手&#39;"></p><p><strong>第一次握手</strong>：建立连接时，客户端发送 SYN 包(seq=x)到服务器，并进入 SYN_SEND 状态，等待服务器确认； </p><p><strong>第二次握手</strong>：服务器收到SYN包，必须确认客户端SYN（ack=x+1），同时自己也发送一个 SYN 包（seq=y），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态； </p><p><strong>第三次握手</strong>：客户端收到服务器的 SYN＋ACK 包，向服务器发送确认包 ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p><blockquote><p>SYN 是需要消耗一个序列号的，下次发送对应的ACK序列号要加1，为什么呢？<br>&emsp; 凡是需要对端确认的，一定消耗TCP报文的序列号。SYN需要对端的确认，而ACK并不需要，因此 SYN 消耗一个序列号而 ACK 不需要。</p></blockquote><p><strong>为什么不是两次？根本原因: 无法确认客户端的接收能力。</strong></p><p>分析如下:<br>如果是两次，客户端现在发的SYN报文想握手，但是由于当前的网络原因这个包滞留而迟迟没有到达服务端，TCP 以为这是丢了包，于是重传，两次握手建立好了连接。</p><p>但是连接关闭后，如果这个滞留在网路中的包（还存活）到达了服务端，这时候由于是两次握手，服务端只要接收到该滞留包然后发送相应的数据包，跟客户端建立连接，但是上一个数据包已经失效，现在这个连接对于客户端来说并不承认，而服务端还等着客户端传输数据响应，这就带来了连接资源的浪费。</p><hr><h4 id="TCP-四次挥手的过程"><a href="#TCP-四次挥手的过程" class="headerlink" title="TCP 四次挥手的过程"></a>TCP 四次挥手的过程</h4><p><img src="/2021/02/20/%E9%9D%A2%E8%AF%95-tcp%E5%8D%8F%E8%AE%AE/b.jpg" alt="&#39;四次挥手&#39;"></p><p><strong>第一次挥手</strong> 客户端发送一个FIN报文（seq=p），用来关闭客户端到服务器的数据传送；</p><p><strong>第二次挥手</strong> 服务器收到这个FIN，它发回一个ACK（ack=p+1），确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号；</p><p><strong>第三次挥手</strong> 服务器关闭与客户端的连接，发送一个 FIN+ACK（seq=q,ack=p+1）给客户端 A；</p><p><strong>第四次挥手</strong>客户端发回ACK（ack=q+1）报文确认，并将确认序号设置为收到序号加 1。</p><blockquote><p>这个时候，客户端需要等待足够长的时间，具体来说，是 2 个 MSL(Maximum Segment Lifetime，报文最大生存时间),在这段时间内如果客户端没有收到服务端的重发请求，那么表示 ACK 成功到达，挥手结束，否则客户端重发 ACK。</p></blockquote><p><strong>等待2MSL的意义</strong><br>如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。<br>之所以要等待 2 MSL：</p><ul><li>1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端</li><li>1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达</li></ul><p><strong>为什么是四次挥手而不是三次？</strong><br>因为服务端在接收到FIN, 往往不会立即返回FIN, 必须等到服务端所有的报文都发送完毕了，才能发FIN。因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。 这就造成了四次挥手。</p><p>如果是三次挥手会有什么问题？<br>等于说服务端将ACK和FIN的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为FIN没有到达客户端，从而让客户端不断的重发FIN。</p><hr><h4 id="TCP-报文头部的字段"><a href="#TCP-报文头部的字段" class="headerlink" title="TCP 报文头部的字段"></a>TCP 报文头部的字段</h4><p><img src="/2021/02/20/%E9%9D%A2%E8%AF%95-tcp%E5%8D%8F%E8%AE%AE/c.jpg" alt="&#39;tcp报文头部&#39;"></p><p><strong>源端口、目标端口</strong><br>如何标识唯一标识一个连接？答案是 TCP 连接的四元组——源 IP、源端口、目标 IP 和目标端口。</p><p>那 TCP 报文怎么没有源 IP 和目标 IP 呢？这是因为在 IP 层就已经处理了 IP 。TCP 只需要记录两者的端口即可。</p><p><strong>序列号</strong><br>即Sequence number, 指的是本报文段第一个字节的序列号。</p><p>从图中可以看出，序列号是一个长为 4 个字节，也就是 32 位的无符号整数，表示范围为 0 ~ 2^32 - 1。如果到达最大值了后就循环到0。</p><p>序列号在 TCP 通信的过程中有两个作用:</p><p>在 SYN 报文中交换彼此的初始序列号。<br>保证数据包按正确的顺序组装。</p><p><strong>ISN</strong><br>即Initial Sequence Number（初始序列号）,在三次握手的过程当中，双方会用过SYN报文来交换彼此的 ISN。</p><p>ISN 并不是一个固定的值，而是每 4 ms 加一，溢出则回到 0，这个算法使得猜测 ISN 变得很困难。那为什么要这么做？</p><p>如果 ISN 被攻击者预测到，要知道源 IP 和源端口号都是很容易伪造的，当攻击者猜测 ISN 之后，直接伪造一个 RST 后，就可以强制连接关闭的，这是非常危险的。</p><p>而动态增长的 ISN 大大提高了猜测 ISN 的难度。</p><p><strong>确认号</strong><br>即ACK(Acknowledgment number)。用来告知对方下一个期望接收的序列号，小于ACK的所有字节已经全部收到。</p><p><strong>标记位</strong><br>常见的标记位有SYN,ACK,FIN,RST,PSH。</p><p>SYN 和 ACK 已经在上文说过，后三个解释如下: FIN：即 Finish，表示发送方准备断开连接。</p><p>RST：即 Reset，用来强制断开连接。</p><p>PSH：即 Push, 告知对方这些数据包收到后应该马上交给上层的应用，不能缓存。</p><p><strong>窗口大小</strong><br>占用两个字节，也就是 16 位，但实际上是不够用的。因此 TCP 引入了窗口缩放的选项，作为窗口缩放的比例因子，这个比例因子的范围在 0 ~ 14，比例因子可以将窗口的值扩大为原来的 2 ^ n 次方。</p><p><strong>校验和</strong><br>占用两个字节，防止传输过程中数据包有损坏，如果遇到校验和有差错的报文，TCP 直接丢弃之，等待重传</p><hr><h4 id="TCP-的流量控制"><a href="#TCP-的流量控制" class="headerlink" title="TCP 的流量控制"></a>TCP 的流量控制</h4><p>对于发送端和接收端而言，TCP 需要把发送的数据放到发送缓存区, 将接收的数据放到接收缓存区。</p><p>而流量控制索要做的事情，就是在通过接收缓存区的大小，控制发送端的发送。如果对方的接收缓存区满了，就不能再继续发送了。</p><p>要具体理解流量控制，首先需要了解滑动窗口的概念。</p><p><strong>TCP 滑动窗口</strong><br>TCP 滑动窗口分为两种: <strong>发送窗口</strong>和<strong>接收窗口</strong>。</p><p><strong>发送窗口</strong><br>发送端的滑动窗口结构如下:<br><img src="/2021/02/20/%E9%9D%A2%E8%AF%95-tcp%E5%8D%8F%E8%AE%AE/d.jpg" alt="发送端的滑动窗口"></p><p>其中包含四大部分:<br>已发送且已确认<br>已发送但未确认<br>未发送但可以发送<br>未发送也不可以发送</p><p>接收窗口<br>接收端的窗口结构如下:<br><img src="/2021/02/20/%E9%9D%A2%E8%AF%95-tcp%E5%8D%8F%E8%AE%AE/e.jpg" alt="接收端的滑动窗口"></p><p><strong>流量控制过程</strong></p><p>这里我们不用太复杂的例子，以一个最简单的来回来模拟一下流量控制的过程，方便大家理解。</p><p>首先双方三次握手，初始化各自的窗口大小，均为 200 个字节。</p><p>假如当前发送端给接收端发送 100 个字节，那么此时对于发送端而言，SND.NXT 当然要右移 100 个字节，也就是说当前的可用窗口减少了 100 个字节，这很好理解。</p><p>现在这 100 个到达了接收端，被放到接收端的缓冲队列中。不过此时由于大量负载的原因，接收端处理不了这么多字节，只能处理 40 个字节，剩下的 60 个字节被留在了缓冲队列中。</p><p>注意了，此时接收端的情况是处理能力不够用啦，你发送端给我少发点，所以此时接收端的接收窗口应该缩小，具体来说，缩小 60 个字节，由 200 个字节变成了 140 字节，因为缓冲队列还有 60 个字节没被应用拿走。</p><p>因此，接收端会在 ACK 的报文首部带上缩小后的滑动窗口 140 字节，发送端对应地调整发送窗口的大小为 140 个字节。</p><p>此时对于发送端而言，已经发送且确认的部分增加 40 字节，也就是 SND.UNA 右移 40 个字节，同时发送窗口缩小为 140 个字节。</p><p>这也就是流量控制的过程。尽管回合再多，整个控制的过程和原理是一样的。</p><hr><h4 id="TCP-的拥塞控制"><a href="#TCP-的拥塞控制" class="headerlink" title="TCP 的拥塞控制"></a>TCP 的拥塞控制</h4><p>如果当前网络特别差，特别容易丢包，那么发送端就应该注意一些了，即拥塞控制需要处理的问题。</p><p>对于拥塞控制来说，TCP 每条连接都需要维护两个核心状态:</p><ul><li>拥塞窗口（Congestion Window，cwnd）</li><li>慢启动阈值（Slow Start Threshold，ssthresh）</li></ul><p>涉及到的算法有这几个:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">慢启动</span><br><span class="line">拥塞避免</span><br><span class="line">快速重传和快速恢复</span><br></pre></td></tr></table></figure><p><strong>拥塞窗口</strong><br>拥塞窗口（Congestion Window，cwnd）是指目前自己还能传输的数据量大小。<br>那么之前介绍了接收窗口的概念，两者有什么区别呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">接收窗口(rwnd)是接收端给的限制</span><br><span class="line">拥塞窗口(cwnd)是发送端的限制</span><br></pre></td></tr></table></figure><p>两个窗口限制发送窗口的大小。<br>有了这两个窗口，如何来计算发送窗口？<br><code>发送窗口大小 = min(rwnd, cwnd)</code><br>拥塞控制，就是来控制cwnd的变化</p><p><strong>慢启动</strong><br>刚开始进入传输数据的时候，你是不知道现在的网路到底是稳定还是拥堵的，如果做的太激进，发包太急，那么疯狂丢包，造成雪崩式的网络灾难。</p><p>因此，拥塞控制首先就是要采用一种保守的算法来慢慢地适应整个网路，这种算法叫慢启动。运作过程如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先，三次握手，双方宣告自己的接收窗口大小</span><br><span class="line">双方初始化自己的拥塞窗口(cwnd)大小</span><br><span class="line">在开始传输的一段时间，发送端每收到一个 ACK，拥塞窗口大小加 1，也就是说，每经过一个 RTT，cwnd 翻倍。如果说初始窗口为 10，那么第一轮 10 个报文传完且发送端收到 ACK 后，cwnd 变为 20，第二轮变为 40，第三轮变为 80，依次类推。</span><br></pre></td></tr></table></figure><p>难道就这么无止境地翻倍下去？当然不可能。它的阈值叫做慢启动阈值，当 cwnd 到达这个阈值之后，好比踩了下刹车，别涨了那么快了，老铁，先 hold 住！</p><p>在到达阈值后，如何来控制 cwnd 的大小呢？</p><p>这就是拥塞避免做的事情了。</p><p><strong>拥塞避免</strong><br>原来每收到一个 ACK，cwnd 加1，现在到达阈值了，cwnd 只能加这么一点: 1 / cwnd。那你仔细算算，一轮 RTT 下来，收到 cwnd 个ACK,那最后拥塞窗口的大小 cwnd 总共才增加 1。<br>也就是说，以前一个 RTT 下来，cwnd翻倍，现在cwnd只是增加 1 而已。<br>当然，<strong>慢启动</strong>和<strong>拥塞避免</strong>是一起作用的，是一体的。</p><p><strong>快速重传和快速恢复</strong></p><ul><li>快速重传</li></ul><p>在 TCP 传输的过程中，如果发生了丢包，即接收端发现数据段不是按序到达的时候，接收端的处理是重复发送之前的 ACK。</p><p>比如第 5 个包丢了，即使第 6、7 个包到达的接收端，接收端也一律返回第 4 个包的 ACK。当发送端收到 3 个重复的 ACK 时，意识到丢包了，于是马上进行重传，不用等到一个 RTO 的时间到了才重传。</p><p>这就是<strong>快速重传</strong>，它解决的是是否需要重传的问题。</p><ul><li>选择性重传</li></ul><p>那你可能会问了，既然要重传，那么只重传第 5 个包还是第5、6、7 个包都重传呢？</p><p>当然第 6、7 个都已经到达了，TCP 的设计者也不傻，已经传过去干嘛还要传？干脆记录一下哪些包到了，哪些没到，针对性地重传。</p><p>在收到发送端的报文后，接收端回复一个ACK报文，那么在这个报文首部的可选项中，就可以加上SACK这个属性，通过left edge和right edge告知发送端已经收到了哪些区间的数据报。因此，即使第 5 个包丢包了，当收到第6、7个包之后，接收端依然会告诉发送端，这两个包到了。剩下第5个包没到，就重传这个包。这个过程也叫做选择性重传(SACK，Selective Acknowledgment)，它解决的是如何重传的问题。</p><ul><li>快速恢复</li></ul><p>当然，发送端收到三次重复ACK之后，发现丢包，觉得现在的网络已经有些拥塞了，自己会进入快速恢复阶段。<br>在这个阶段，发送端如下改变：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">拥塞阈值降低为 cwnd 的一半</span><br><span class="line">cwnd 的大小变为拥塞阈值</span><br><span class="line">cwnd 线性增加</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h4 id=&quot;TCP-和-UDP-的区别&quot;&gt;&lt;a href=&quot;#TCP-和-UDP-的区别&quot; class=&quot;headerlink&quot; title=&quot;TCP 和 UDP 的区别&quot;&gt;&lt;/a&gt;TCP 和 UDP 的区别&lt;/h4&gt;&lt;p&gt;tcp是一个面向连接的、可靠的、基于字节流</summary>
      
    
    
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>flask蓝图</title>
    <link href="http://example.com/2021/02/20/flask%E8%93%9D%E5%9B%BE/"/>
    <id>http://example.com/2021/02/20/flask%E8%93%9D%E5%9B%BE/</id>
    <published>2021-02-19T16:16:05.000Z</published>
    <updated>2021-02-19T16:25:00.370Z</updated>
    
    <content type="html"><![CDATA[<h4 id="对Flask蓝图-Blueprint-的理解？"><a href="#对Flask蓝图-Blueprint-的理解？" class="headerlink" title="对Flask蓝图(Blueprint)的理解？"></a>对Flask蓝图(Blueprint)的理解？</h4><p><strong>蓝图的定义</strong></p><p>蓝图 /Blueprint 是Flask应用程序组件化的方法，可以在一个应用内或跨越多个项目共用蓝图。使用蓝图可以极大简化大型应用的开发难度，也为Flask扩展提供了一种在应用中注册服务的集中式机制。</p><hr><ul><li>蓝图的应用场景：</li></ul><ol><li><p>把一个应用分解为一个蓝图的集合。这对大型应用是理想的。一个项目可以实例化一个应用对象，初始化几个扩展，并注册一集合的蓝图。</p></li><li><p>以URL前缀和/或子域名，在应用上注册一个蓝图。URL前缀/子域名中的参数即成为这个蓝图下的所有视图函数的共同的视图参数（默认情况下）在一个应用中用不同的URL规则多次注册一个蓝图。</p></li><li><p>通过蓝图提供模板过滤器、静态文件、模板和其他功能。一个蓝图不一定要实现应用或视图函数。</p></li><li><p>初始化一个Flask扩展时，在这些情况中注册一个蓝图。</p></li></ol><ul><li>蓝图的缺点：</li></ul><ol><li>不能在应用创建后撤销注册一个蓝图而不销毁整个应用对象。</li></ol><ul><li>使用蓝图的三个步骤</li></ul><ol><li>创建一个蓝图对象<br><code>blue = Blueprint(&quot;blue&quot;,__name__)</code></li><li>在这个蓝图对象上进行操作，例如注册路由、指定静态文件夹、注册模板过滤器…<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@blue.route(&#39;&#x2F;&#39;)</span><br><span class="line">def blue_index():</span><br><span class="line">    return &quot;Welcome to my blueprint&quot;</span><br></pre></td></tr></table></figure></li><li>在应用对象上注册这个蓝图对象<br><code>app.register_blueprint(blue,url_prefix=&quot;/blue&quot;)</code></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;对Flask蓝图-Blueprint-的理解？&quot;&gt;&lt;a href=&quot;#对Flask蓝图-Blueprint-的理解？&quot; class=&quot;headerlink&quot; title=&quot;对Flask蓝图(Blueprint)的理解？&quot;&gt;&lt;/a&gt;对Flask蓝图(Blueprin</summary>
      
    
    
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>python设计模式</title>
    <link href="http://example.com/2021/02/19/python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/02/19/python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-19T09:41:14.000Z</published>
    <updated>2021-02-19T16:34:03.901Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>python设计模式相关</p></blockquote><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 装饰器方法</span><br><span class="line">def singleton(cls):</span><br><span class="line">instances &#x3D; &#123;&#125;</span><br><span class="line">def wraper(*agrs,**kwargs):</span><br><span class="line">if cls not in instaces:</span><br><span class="line">isntances[cls] &#x3D; cls(*agrs,**kwargs)</span><br><span class="line">return instances[cls]</span><br><span class="line">return wraper</span><br><span class="line"></span><br><span class="line">@singleton</span><br><span class="line">class Foo:</span><br><span class="line">pass</span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line"></span><br><span class="line"># new方法</span><br><span class="line">class Singleton:</span><br><span class="line">def __new__(cls,*args,**kwargs):</span><br><span class="line">if not hasattr(cls,&#39;_instance&#39;):</span><br><span class="line">cls._instance &#x3D; super(Singleton,cls).__new__(cls,*args,**kwargs)</span><br><span class="line">return cls._instance</span><br><span class="line"></span><br><span class="line">class Foo(Singleton):</span><br><span class="line">pass</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;python设计模式相关&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h4&gt;&lt;figure class=&quot;hig</summary>
      
    
    
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>无题</title>
    <link href="http://example.com/2021/02/19/%E9%9D%92%E5%B1%B1%E5%A4%84%E5%A4%84%E5%9F%8B%E5%BF%A0%E9%AA%A8/"/>
    <id>http://example.com/2021/02/19/%E9%9D%92%E5%B1%B1%E5%A4%84%E5%A4%84%E5%9F%8B%E5%BF%A0%E9%AA%A8/</id>
    <published>2021-02-19T08:59:46.000Z</published>
    <updated>2021-02-20T06:16:27.699Z</updated>
    
    <content type="html"><![CDATA[<h4 id="干"><a href="#干" class="headerlink" title="干"></a>干</h4><p>&emsp;&emsp;中印边境的冲突在去年就传出我方将士伤亡，虽说沙场伤亡之事不可避免，但在和平年代的牺牲总是惋惜，更何况是对于印度这无信用的国家，现在消息放出来还是起一身鸡皮疙瘩，冲突事件对我方造成一人重伤，四人牺牲的损失，其年龄最小的将士才不到20，他们的青春年华献给了祖国边疆，也定格在那里，在此敬礼！</p><p>&emsp;&emsp;将士们年纪轻轻就保家卫国，相比现在的自己一副唯唯诺诺的窝囊废样子，着实羞愧，之前的意气风华也不知跑哪去了，心心念念参军报国去部队里历练，现在也成过眼云烟，成说说而已的谈资，安逸得不像话，曾经的热血体魄毅力慢慢殆尽。在社会这条狭路上过往，还是要拼搏亮剑，人无需再少年，吾辈仍需努力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;干&quot;&gt;&lt;a href=&quot;#干&quot; class=&quot;headerlink&quot; title=&quot;干&quot;&gt;&lt;/a&gt;干&lt;/h4&gt;&lt;p&gt;&amp;emsp;&amp;emsp;中印边境的冲突在去年就传出我方将士伤亡，虽说沙场伤亡之事不可避免，但在和平年代的牺牲总是惋惜，更何况是对于印度这无信用的国家</summary>
      
    
    
    
    
    <category term="随想" scheme="http://example.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>linux终端每次需要更新source ~/bashrc</title>
    <link href="http://example.com/2021/02/18/linux%E7%BB%88%E7%AB%AF%E6%AF%8F%E6%AC%A1%E9%9C%80%E8%A6%81%E6%9B%B4%E6%96%B0source%20bashrc/"/>
    <id>http://example.com/2021/02/18/linux%E7%BB%88%E7%AB%AF%E6%AF%8F%E6%AC%A1%E9%9C%80%E8%A6%81%E6%9B%B4%E6%96%B0source%20bashrc/</id>
    <published>2021-02-18T14:01:12.000Z</published>
    <updated>2021-02-19T16:26:39.660Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过ssh连接linux打开终端时，由于需要设定的环境，每次都要执行source ~/bashrc以更新当前环境</p></blockquote><h4 id="一、-bashrc"><a href="#一、-bashrc" class="headerlink" title="一、.bashrc"></a>一、.bashrc</h4><p>.bashrc是home目录下的一个shell文件，用于储存用户的个性化设置，比如个性化指令，设定环境路径或设置提示符等。在bash每次启动时都会加载.bashrc文件中的内容，并根据内容定制当前bash的配置和环境。</p><h4 id="二、配置文件的作用域"><a href="#二、配置文件的作用域" class="headerlink" title="二、配置文件的作用域"></a>二、配置文件的作用域</h4><ul><li><p>/etc/profile：<br>此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行. 并从/etc/profile.d目录的配置文件中搜集shell的设置。</p></li><li><p>/etc/bashrc:<br>为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取（即每次新开一个终端，都会执行bashrc）。</p></li><li><p>~/.bash_profile:<br>每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次。默认情况下,设置一些环境变量,执行用户的.bashrc文件。</p></li><li><p>~/.bashrc:<br>该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。</p></li><li><p>~/.bash_logout:<br>当每次退出系统(退出bash shell)时,执行该文件. 另外,/etc/profile中设定的变量(全局)的可以作用于任何用户,而~/.bashrc等中设定的变量(局部)只能继承 /etc/profile中的变量,他们是”父子”关系。</p></li><li><p>~/.bash_profile:<br>是交互式、login 方式进入 bash 运行的~/.bashrc 是交互式 non-login 方式进入 bash 运行的通常二者设置大致相同，所以通常前者会调用后者。</p></li></ul><h4 id="三、Linux启动时读取配置文件的顺序"><a href="#三、Linux启动时读取配置文件的顺序" class="headerlink" title="三、Linux启动时读取配置文件的顺序"></a>三、Linux启动时读取配置文件的顺序</h4><p>在登录Linux时，首先启动<strong>/etc/profile</strong> 文件，然后再启动用户目录下的<strong>~/.bash_profile</strong>、<strong>~/.bash_login</strong>或 <strong>~/.profile</strong>文件中的其中一个，执行的顺序为：<strong>~/.bash_profile</strong>、<strong>~/.bash_login</strong>、 <strong>~/.profile</strong>，如果<strong>~/.bash_profile</strong>文件存在的话，一般还会执行 <strong>~/.bashrc</strong>文件。</p><ul><li><strong>所以，这些配置文件的执行顺序为</strong>：<strong>/etc/profile</strong> → (<strong>~/.bash_profile</strong> | <strong>~/.bash_login</strong> | <strong>~/.profile</strong>)→ <strong>~/.bashrc</strong> →<strong>/etc/bashrc</strong> → <strong>~/.bash_logout</strong></li></ul><h4 id="四、解决方法"><a href="#四、解决方法" class="headerlink" title="四、解决方法"></a>四、解决方法</h4><p>由于用户目录下的(<strong>~/.bash_profile</strong> | <strong>~/.bash_login</strong> | <strong>~/.profile</strong>)文件不存在，那么，依赖这些文件启动的配置就失效，每次登陆终端都要手动输入source ~/.bashrc。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如在~&#x2F;.bash_profile文件中没有下面的代码</span><br><span class="line">if [ -f ~&#x2F;.bashrc ];  then </span><br><span class="line">        source .bashrc</span><br><span class="line">fi </span><br></pre></td></tr></table></figure><p><strong>所以</strong>，解决方法就直接<code>vi</code>生成.bash_profile文件，并写入<code>source .bashrc</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [-f .bashrc ]; then</span><br><span class="line">source .bashrc </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>之后，打开新终端可以自动执行source ~/.bashrc更新环境。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;通过ssh连接linux打开终端时，由于需要设定的环境，每次都要执行source ~/bashrc以更新当前环境&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;一、-bashrc&quot;&gt;&lt;a href=&quot;#一、-bashrc&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>python的mixin模式</title>
    <link href="http://example.com/2021/02/15/python%E7%9A%84mixin%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/02/15/python%E7%9A%84mixin%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-15T07:15:59.000Z</published>
    <updated>2021-02-15T07:16:17.341Z</updated>
    
    
    
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>开篇词</title>
    <link href="http://example.com/2021/02/15/%E5%BC%80%E7%AF%87%E8%AF%8D/"/>
    <id>http://example.com/2021/02/15/%E5%BC%80%E7%AF%87%E8%AF%8D/</id>
    <published>2021-02-15T07:03:21.000Z</published>
    <updated>2021-02-15T07:06:43.960Z</updated>
    
    <content type="html"><![CDATA[<h3 id="还是想太多"><a href="#还是想太多" class="headerlink" title="还是想太多"></a>还是想太多</h3><p>日子还是要过的，梦想总该有，放心里就好了，生活已经给你一大巴掌了，总该长点记性，比别人在象牙塔多混三年，也是时候出来撞南墙了，不能让人差得太远，不能输！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;还是想太多&quot;&gt;&lt;a href=&quot;#还是想太多&quot; class=&quot;headerlink&quot; title=&quot;还是想太多&quot;&gt;&lt;/a&gt;还是想太多&lt;/h3&gt;&lt;p&gt;日子还是要过的，梦想总该有，放心里就好了，生活已经给你一大巴掌了，总该长点记性，比别人在象牙塔多混三年，也是时候出来</summary>
      
    
    
    
    
    <category term="杂项" scheme="http://example.com/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>My New Posts</title>
    <link href="http://example.com/2021/02/14/My-New-Posts/"/>
    <id>http://example.com/2021/02/14/My-New-Posts/</id>
    <published>2021-02-13T16:19:02.000Z</published>
    <updated>2021-02-13T16:19:02.677Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>My next Post</title>
    <link href="http://example.com/2021/02/13/My-next-Post-2/"/>
    <id>http://example.com/2021/02/13/My-next-Post-2/</id>
    <published>2021-02-13T13:28:40.000Z</published>
    <updated>2021-02-13T14:46:17.197Z</updated>
    
    <content type="html"><![CDATA[<h4 id="hahahaha"><a href="#hahahaha" class="headerlink" title="hahahaha"></a>hahahaha</h4><blockquote><p>fff </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;hahahaha&quot;&gt;&lt;a href=&quot;#hahahaha&quot; class=&quot;headerlink&quot; title=&quot;hahahaha&quot;&gt;&lt;/a&gt;hahahaha&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;fff &lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    
    <category term="lalala" scheme="http://example.com/tags/lalala/"/>
    
  </entry>
  
  <entry>
    <title>My next Post</title>
    <link href="http://example.com/2021/02/13/My-next-Post-1/"/>
    <id>http://example.com/2021/02/13/My-next-Post-1/</id>
    <published>2021-02-13T13:05:03.000Z</published>
    <updated>2021-02-13T13:05:03.869Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>My next Post</title>
    <link href="http://example.com/2021/02/13/My-next-Post/"/>
    <id>http://example.com/2021/02/13/My-next-Post/</id>
    <published>2021-02-13T12:42:45.000Z</published>
    <updated>2021-02-13T12:42:45.216Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>My New Post</title>
    <link href="http://example.com/2021/02/13/My-New-Post/"/>
    <id>http://example.com/2021/02/13/My-New-Post/</id>
    <published>2021-02-13T12:37:27.000Z</published>
    <updated>2021-02-13T12:37:27.115Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/02/11/hello-world/"/>
    <id>http://example.com/2021/02/11/hello-world/</id>
    <published>2021-02-10T16:41:15.811Z</published>
    <updated>2021-02-10T16:41:15.811Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
